{"version":3,"sources":["ImageCropOverlay.tsx"],"names":["React","Animated","StyleSheet","View","useRecoilState","cropSizeState","imageBoundsState","accumulatedPanState","GestureHandlerRootView","PanGestureHandler","State","useContext","EditorContext","horizontalSections","verticalSections","ImageCropOverlay","selectedFrameSection","setSelectedFrameSection","useState","cropSize","setCropSize","imageBounds","accumulatedPan","setAccumluatedPan","fixedAspectRatio","lockAspectRatio","minimumCropDimensions","animatedCropSize","width","Value","height","panX","useRef","x","panY","y","useEffect","checkCropBounds","translationX","translationY","setValue","newSize","imageAspectRatio","isMovingSection","isLeft","endsWith","isTop","startsWith","onOverlayMove","nativeEvent","event","current","useNativeDriver","getTargetCropFrameBounds","initialWidth","initialHeight","position","onOverlayRelease","checkResizeBounds","onHandlerStateChange","state","END","accDx","limitedXPos","accDy","limitedYPos","maxWidth","maxHeight","minWidth","minHeight","animatedWidth","animatedHeight","finalHeight","finalWidth","styles","container","e","overlay","transform","translateX","add","translateY","map","hsection","sectionRow","vsection","key","defaultSection","cornerMarker","top","borderTopWidth","bottom","borderBottomWidth","left","borderLeftWidth","right","borderRightWidth","create","backgroundColor","borderColor","borderWidth","flexDirection","flex","justifyContent","alignItems"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  TouchableOpacity,\n  requireNativeComponent,\n  Platform,\n  ViewPropTypes,\n} from \"react-native\";\nimport _ from \"lodash\";\nimport { useRecoilState } from \"recoil\";\nimport { cropSizeState, imageBoundsState, accumulatedPanState } from \"./Store\";\nimport {\n  GestureHandlerRootView,\n  PanGestureHandler,\n  PanGestureHandlerGestureEvent,\n  State,\n} from \"react-native-gesture-handler\";\nimport { useContext } from \"react\";\nimport { EditorContext } from \"./index\";\n\nconst horizontalSections = [\"top\", \"middle\", \"bottom\"];\nconst verticalSections = [\"left\", \"middle\", \"right\"];\n\nconst ImageCropOverlay = () => {\n  // Record which section of the fram window has been pressed\n  // this determines whether it is a translation or scaling gesture\n  const [selectedFrameSection, setSelectedFrameSection] = React.useState(\"\");\n\n  // Shared state and bits passed through recoil to avoid prop drilling\n  const [cropSize, setCropSize] = useRecoilState(cropSizeState);\n  const [imageBounds] = useRecoilState(imageBoundsState);\n  const [accumulatedPan, setAccumluatedPan] =\n    useRecoilState(accumulatedPanState);\n  // Editor context\n  const { fixedAspectRatio, lockAspectRatio, minimumCropDimensions } =\n    useContext(EditorContext);\n\n  const [animatedCropSize] = React.useState({\n    width: new Animated.Value(cropSize.width),\n    height: new Animated.Value(cropSize.height),\n  });\n\n  // pan X and Y values to track the current delta of the pan\n  // in both directions - this should be zeroed out on release\n  // and the delta added onto the accumulatedPan state\n  const panX = React.useRef(new Animated.Value(imageBounds.x));\n  const panY = React.useRef(new Animated.Value(imageBounds.y));\n\n  React.useEffect(() => {\n    // Move the pan to the origin and check the bounds so it clicks to\n    // the corner of the image\n    checkCropBounds({\n      translationX: 0,\n      translationY: 0,\n    });\n    // When the crop size updates make sure the animated value does too!\n    animatedCropSize.height.setValue(cropSize.height);\n    animatedCropSize.width.setValue(cropSize.width);\n  }, [cropSize]);\n\n  React.useEffect(() => {\n    // Update the size of the crop window based on the new image bounds\n    let newSize = { width: 0, height: 0 };\n    const { width, height } = imageBounds;\n    const imageAspectRatio = width / height;\n    // Then check if the cropping aspect ratio is smaller\n    if (fixedAspectRatio < imageAspectRatio) {\n      // If so calculate the size so its not greater than the image width\n      newSize.height = height;\n      newSize.width = height * fixedAspectRatio;\n    } else {\n      // else, calculate the size so its not greater than the image height\n      newSize.width = width;\n      newSize.height = width / fixedAspectRatio;\n    }\n    // Set the size of the crop overlay\n    setCropSize(newSize);\n  }, [imageBounds]);\n\n  // Function that sets which sections allow for translation when\n  // pressed\n  const isMovingSection = () => {\n    return (\n      selectedFrameSection == \"topmiddle\" ||\n      selectedFrameSection == \"middleleft\" ||\n      selectedFrameSection == \"middleright\" ||\n      selectedFrameSection == \"middlemiddle\" ||\n      selectedFrameSection == \"bottommiddle\"\n    );\n  };\n\n  // Check what resizing / translation needs to be performed based on which section was pressed\n  const isLeft = selectedFrameSection.endsWith(\"left\");\n  const isTop = selectedFrameSection.startsWith(\"top\");\n\n  const onOverlayMove = ({ nativeEvent }: PanGestureHandlerGestureEvent) => {\n    if (selectedFrameSection !== \"\") {\n      // Check if the section pressed is one to translate the crop window or not\n      if (isMovingSection()) {\n        // If it is then use an animated event to directly pass the tranlation\n        // to the pan refs\n        Animated.event(\n          [\n            {\n              translationX: panX.current,\n              translationY: panY.current,\n            },\n          ],\n          { useNativeDriver: false }\n        )(nativeEvent);\n      } else {\n        // Else its a scaling operation\n        const { x, y } = getTargetCropFrameBounds(nativeEvent);\n        if (isTop) {\n          panY.current.setValue(-y);\n        }\n        if (isLeft) {\n          panX.current.setValue(-x);\n        }\n        // Finally update the animated width to the values the crop\n        // window has been resized to\n        animatedCropSize.width.setValue(cropSize.width + x);\n        animatedCropSize.height.setValue(cropSize.height + y);\n      }\n    } else {\n      // We need to set which section has been pressed\n      const { x, y } = nativeEvent;\n      const { width: initialWidth, height: initialHeight } = cropSize;\n      let position = \"\";\n      // Figure out where we pressed vertically\n      if (y / initialHeight < 0.333) {\n        position = position + \"top\";\n      } else if (y / initialHeight < 0.667) {\n        position = position + \"middle\";\n      } else {\n        position = position + \"bottom\";\n      }\n      // Figure out where we pressed horizontally\n      if (x / initialWidth < 0.333) {\n        position = position + \"left\";\n      } else if (x / initialWidth < 0.667) {\n        position = position + \"middle\";\n      } else {\n        position = position + \"right\";\n      }\n      setSelectedFrameSection(position);\n    }\n  };\n\n  const getTargetCropFrameBounds = ({\n    translationX,\n    translationY,\n  }: Partial<PanGestureHandlerGestureEvent[\"nativeEvent\"]>) => {\n    let x = 0;\n    let y = 0;\n    if (translationX && translationY) {\n      if (translationX < translationY) {\n        x = (isLeft ? -1 : 1) * translationX;\n        if (lockAspectRatio) {\n          y = x / fixedAspectRatio;\n        } else {\n          y = (isTop ? -1 : 1) * translationY;\n        }\n      } else {\n        y = (isTop ? -1 : 1) * translationY;\n        if (lockAspectRatio) {\n          x = y * fixedAspectRatio;\n        } else {\n          x = (isLeft ? -1 : 1) * translationX;\n        }\n      }\n    }\n    return { x, y };\n  };\n\n  const onOverlayRelease = (\n    nativeEvent: PanGestureHandlerGestureEvent[\"nativeEvent\"]\n  ) => {\n    // Check if the section pressed is one to translate the crop window or not\n    if (isMovingSection()) {\n      // Ensure the cropping overlay has not been moved outside of the allowed bounds\n      checkCropBounds(nativeEvent);\n    } else {\n      // Else its a scaling op - check that the resizing didnt take it out of bounds\n      checkResizeBounds(nativeEvent);\n    }\n    // Disable the pan responder so the section tiles can register being pressed again\n    setSelectedFrameSection(\"\");\n  };\n\n  const onHandlerStateChange = ({\n    nativeEvent,\n  }: PanGestureHandlerGestureEvent) => {\n    // Handle any state changes from the pan gesture handler\n    // only looking at when the touch ends atm\n    if (nativeEvent.state === State.END) {\n      onOverlayRelease(nativeEvent);\n    }\n  };\n\n  const checkCropBounds = ({\n    translationX,\n    translationY,\n  }:\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\n    | { translationX: number; translationY: number }) => {\n    // Check if the pan in the x direction exceeds the bounds\n    let accDx = accumulatedPan.x + translationX;\n    // Is the new x pos less than zero?\n    if (accDx <= imageBounds.x) {\n      // Then set it to be zero and set the pan to zero too\n      accDx = imageBounds.x;\n    }\n    // Is the new x pos plus crop width going to exceed the right hand bound\n    else if (accDx + cropSize.width > imageBounds.width + imageBounds.x) {\n      // Then set the x pos so the crop frame touches the right hand edge\n      let limitedXPos = imageBounds.x + imageBounds.width - cropSize.width;\n      accDx = limitedXPos;\n    } else {\n      // It's somewhere in between - no formatting required\n    }\n    // Check if the pan in the y direction exceeds the bounds\n    let accDy = accumulatedPan.y + translationY;\n    // Is the new y pos less the top edge?\n    if (accDy <= imageBounds.y) {\n      // Then set it to be zero and set the pan to zero too\n      accDy = imageBounds.y;\n    }\n    // Is the new y pos plus crop height going to exceed the bottom bound\n    else if (accDy + cropSize.height > imageBounds.height + imageBounds.y) {\n      // Then set the y pos so the crop frame touches the bottom edge\n      let limitedYPos = imageBounds.y + imageBounds.height - cropSize.height;\n      accDy = limitedYPos;\n    } else {\n      // It's somewhere in between - no formatting required\n    }\n    // Record the accumulated pan and reset the pan refs to zero\n    panX.current.setValue(0);\n    panY.current.setValue(0);\n    setAccumluatedPan({ x: accDx, y: accDy });\n  };\n\n  const checkResizeBounds = ({\n    translationX,\n    translationY,\n  }:\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\n    | { translationX: number; translationY: number }) => {\n    // Check we haven't gone out of bounds when resizing - allow it to be\n    // resized up to the appropriate bounds if so\n    const { width: maxWidth, height: maxHeight } = imageBounds;\n    const { width: minWidth, height: minHeight } = minimumCropDimensions;\n    const { x, y } = getTargetCropFrameBounds({ translationX, translationY });\n    const animatedWidth = cropSize.width + x;\n    const animatedHeight = cropSize.height + y;\n    let finalHeight = animatedHeight;\n    let finalWidth = animatedWidth;\n    // Ensure the width / height does not exceed the boundaries -\n    // resize to the max it can be if so\n    if (animatedHeight > maxHeight) {\n      finalHeight = maxHeight;\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\n    } else if (animatedHeight < minHeight) {\n      finalHeight = minHeight;\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\n    }\n    if (animatedWidth > maxWidth) {\n      finalWidth = maxWidth;\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\n    } else if (animatedWidth < minWidth) {\n      finalWidth = minWidth;\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\n    }\n    // Update the accumulated pan with the delta from the pan refs\n    setAccumluatedPan({\n      x: accumulatedPan.x + (isLeft ? -x : 0),\n      y: accumulatedPan.y + (isTop ? -y : 0),\n    });\n    // Zero out the pan refs\n    panX.current.setValue(0);\n    panY.current.setValue(0);\n    // Update the crop size to the size after resizing\n    setCropSize({\n      height: finalHeight,\n      width: finalWidth,\n    });\n  };\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <PanGestureHandler\n        onGestureEvent={onOverlayMove}\n        onHandlerStateChange={(e) => onHandlerStateChange(e)}\n      >\n        <Animated.View\n          style={[\n            styles.overlay,\n            animatedCropSize,\n            {\n              transform: [\n                { translateX: Animated.add(panX.current, accumulatedPan.x) },\n                { translateY: Animated.add(panY.current, accumulatedPan.y) },\n              ],\n            },\n          ]}\n        >\n          {\n            // For reendering out each section of the crop overlay frame\n            horizontalSections.map((hsection) => {\n              return (\n                <View style={styles.sectionRow} key={hsection}>\n                  {verticalSections.map((vsection) => {\n                    const key = hsection + vsection;\n                    return (\n                      <View style={[styles.defaultSection]} key={key}>\n                        {\n                          // Add the corner markers to the topleft,\n                          // topright, bottomleft and bottomright corners to indicate resizing\n                          key == \"topleft\" ||\n                          key == \"topright\" ||\n                          key == \"bottomleft\" ||\n                          key == \"bottomright\" ? (\n                            <View\n                              style={[\n                                styles.cornerMarker,\n                                hsection == \"top\"\n                                  ? { top: -4, borderTopWidth: 7 }\n                                  : { bottom: -4, borderBottomWidth: 7 },\n                                vsection == \"left\"\n                                  ? { left: -4, borderLeftWidth: 7 }\n                                  : { right: -4, borderRightWidth: 7 },\n                              ]}\n                            />\n                          ) : null\n                        }\n                      </View>\n                    );\n                  })}\n                </View>\n              );\n            })\n          }\n        </Animated.View>\n      </PanGestureHandler>\n    </GestureHandlerRootView>\n  );\n};\n\nexport { ImageCropOverlay };\n\nconst styles = StyleSheet.create({\n  container: {\n    height: \"100%\",\n    width: \"100%\",\n    position: \"absolute\",\n  },\n  overlay: {\n    height: 40,\n    width: 40,\n    backgroundColor: \"#33333355\",\n    borderColor: \"#ffffff88\",\n    borderWidth: 1,\n  },\n  sectionRow: {\n    flexDirection: \"row\",\n    flex: 1,\n  },\n  defaultSection: {\n    flex: 1,\n    borderWidth: 0.5,\n    borderColor: \"#ffffff88\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  cornerMarker: {\n    position: \"absolute\",\n    borderColor: \"#ffffff\",\n    height: 30,\n    width: 30,\n  },\n});\n"]}