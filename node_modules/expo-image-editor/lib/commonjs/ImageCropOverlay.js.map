{"version":3,"sources":["ImageCropOverlay.tsx"],"names":["horizontalSections","verticalSections","ImageCropOverlay","selectedFrameSection","setSelectedFrameSection","React","useState","cropSize","setCropSize","cropSizeState","imageBounds","imageBoundsState","accumulatedPan","setAccumluatedPan","accumulatedPanState","fixedAspectRatio","lockAspectRatio","minimumCropDimensions","EditorContext","animatedCropSize","width","Animated","Value","height","panX","useRef","x","panY","y","useEffect","checkCropBounds","translationX","translationY","setValue","newSize","imageAspectRatio","isMovingSection","isLeft","endsWith","isTop","startsWith","onOverlayMove","nativeEvent","event","current","useNativeDriver","getTargetCropFrameBounds","initialWidth","initialHeight","position","onOverlayRelease","checkResizeBounds","onHandlerStateChange","state","State","END","accDx","limitedXPos","accDy","limitedYPos","maxWidth","maxHeight","minWidth","minHeight","animatedWidth","animatedHeight","finalHeight","finalWidth","styles","container","e","overlay","transform","translateX","add","translateY","map","hsection","sectionRow","vsection","key","defaultSection","cornerMarker","top","borderTopWidth","bottom","borderBottomWidth","left","borderLeftWidth","right","borderRightWidth","StyleSheet","create","backgroundColor","borderColor","borderWidth","flexDirection","flex","justifyContent","alignItems"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  TouchableOpacity,\n  requireNativeComponent,\n  Platform,\n  ViewPropTypes,\n} from \"react-native\";\nimport _ from \"lodash\";\nimport { useRecoilState } from \"recoil\";\nimport { cropSizeState, imageBoundsState, accumulatedPanState } from \"./Store\";\nimport {\n  GestureHandlerRootView,\n  PanGestureHandler,\n  PanGestureHandlerGestureEvent,\n  State,\n} from \"react-native-gesture-handler\";\nimport { useContext } from \"react\";\nimport { EditorContext } from \"./index\";\n\nconst horizontalSections = [\"top\", \"middle\", \"bottom\"];\nconst verticalSections = [\"left\", \"middle\", \"right\"];\n\nconst ImageCropOverlay = () => {\n  // Record which section of the fram window has been pressed\n  // this determines whether it is a translation or scaling gesture\n  const [selectedFrameSection, setSelectedFrameSection] = React.useState(\"\");\n\n  // Shared state and bits passed through recoil to avoid prop drilling\n  const [cropSize, setCropSize] = useRecoilState(cropSizeState);\n  const [imageBounds] = useRecoilState(imageBoundsState);\n  const [accumulatedPan, setAccumluatedPan] =\n    useRecoilState(accumulatedPanState);\n  // Editor context\n  const { fixedAspectRatio, lockAspectRatio, minimumCropDimensions } =\n    useContext(EditorContext);\n\n  const [animatedCropSize] = React.useState({\n    width: new Animated.Value(cropSize.width),\n    height: new Animated.Value(cropSize.height),\n  });\n\n  // pan X and Y values to track the current delta of the pan\n  // in both directions - this should be zeroed out on release\n  // and the delta added onto the accumulatedPan state\n  const panX = React.useRef(new Animated.Value(imageBounds.x));\n  const panY = React.useRef(new Animated.Value(imageBounds.y));\n\n  React.useEffect(() => {\n    // Move the pan to the origin and check the bounds so it clicks to\n    // the corner of the image\n    checkCropBounds({\n      translationX: 0,\n      translationY: 0,\n    });\n    // When the crop size updates make sure the animated value does too!\n    animatedCropSize.height.setValue(cropSize.height);\n    animatedCropSize.width.setValue(cropSize.width);\n  }, [cropSize]);\n\n  React.useEffect(() => {\n    // Update the size of the crop window based on the new image bounds\n    let newSize = { width: 0, height: 0 };\n    const { width, height } = imageBounds;\n    const imageAspectRatio = width / height;\n    // Then check if the cropping aspect ratio is smaller\n    if (fixedAspectRatio < imageAspectRatio) {\n      // If so calculate the size so its not greater than the image width\n      newSize.height = height;\n      newSize.width = height * fixedAspectRatio;\n    } else {\n      // else, calculate the size so its not greater than the image height\n      newSize.width = width;\n      newSize.height = width / fixedAspectRatio;\n    }\n    // Set the size of the crop overlay\n    setCropSize(newSize);\n  }, [imageBounds]);\n\n  // Function that sets which sections allow for translation when\n  // pressed\n  const isMovingSection = () => {\n    return (\n      selectedFrameSection == \"topmiddle\" ||\n      selectedFrameSection == \"middleleft\" ||\n      selectedFrameSection == \"middleright\" ||\n      selectedFrameSection == \"middlemiddle\" ||\n      selectedFrameSection == \"bottommiddle\"\n    );\n  };\n\n  // Check what resizing / translation needs to be performed based on which section was pressed\n  const isLeft = selectedFrameSection.endsWith(\"left\");\n  const isTop = selectedFrameSection.startsWith(\"top\");\n\n  const onOverlayMove = ({ nativeEvent }: PanGestureHandlerGestureEvent) => {\n    if (selectedFrameSection !== \"\") {\n      // Check if the section pressed is one to translate the crop window or not\n      if (isMovingSection()) {\n        // If it is then use an animated event to directly pass the tranlation\n        // to the pan refs\n        Animated.event(\n          [\n            {\n              translationX: panX.current,\n              translationY: panY.current,\n            },\n          ],\n          { useNativeDriver: false }\n        )(nativeEvent);\n      } else {\n        // Else its a scaling operation\n        const { x, y } = getTargetCropFrameBounds(nativeEvent);\n        if (isTop) {\n          panY.current.setValue(-y);\n        }\n        if (isLeft) {\n          panX.current.setValue(-x);\n        }\n        // Finally update the animated width to the values the crop\n        // window has been resized to\n        animatedCropSize.width.setValue(cropSize.width + x);\n        animatedCropSize.height.setValue(cropSize.height + y);\n      }\n    } else {\n      // We need to set which section has been pressed\n      const { x, y } = nativeEvent;\n      const { width: initialWidth, height: initialHeight } = cropSize;\n      let position = \"\";\n      // Figure out where we pressed vertically\n      if (y / initialHeight < 0.333) {\n        position = position + \"top\";\n      } else if (y / initialHeight < 0.667) {\n        position = position + \"middle\";\n      } else {\n        position = position + \"bottom\";\n      }\n      // Figure out where we pressed horizontally\n      if (x / initialWidth < 0.333) {\n        position = position + \"left\";\n      } else if (x / initialWidth < 0.667) {\n        position = position + \"middle\";\n      } else {\n        position = position + \"right\";\n      }\n      setSelectedFrameSection(position);\n    }\n  };\n\n  const getTargetCropFrameBounds = ({\n    translationX,\n    translationY,\n  }: Partial<PanGestureHandlerGestureEvent[\"nativeEvent\"]>) => {\n    let x = 0;\n    let y = 0;\n    if (translationX && translationY) {\n      if (translationX < translationY) {\n        x = (isLeft ? -1 : 1) * translationX;\n        if (lockAspectRatio) {\n          y = x / fixedAspectRatio;\n        } else {\n          y = (isTop ? -1 : 1) * translationY;\n        }\n      } else {\n        y = (isTop ? -1 : 1) * translationY;\n        if (lockAspectRatio) {\n          x = y * fixedAspectRatio;\n        } else {\n          x = (isLeft ? -1 : 1) * translationX;\n        }\n      }\n    }\n    return { x, y };\n  };\n\n  const onOverlayRelease = (\n    nativeEvent: PanGestureHandlerGestureEvent[\"nativeEvent\"]\n  ) => {\n    // Check if the section pressed is one to translate the crop window or not\n    if (isMovingSection()) {\n      // Ensure the cropping overlay has not been moved outside of the allowed bounds\n      checkCropBounds(nativeEvent);\n    } else {\n      // Else its a scaling op - check that the resizing didnt take it out of bounds\n      checkResizeBounds(nativeEvent);\n    }\n    // Disable the pan responder so the section tiles can register being pressed again\n    setSelectedFrameSection(\"\");\n  };\n\n  const onHandlerStateChange = ({\n    nativeEvent,\n  }: PanGestureHandlerGestureEvent) => {\n    // Handle any state changes from the pan gesture handler\n    // only looking at when the touch ends atm\n    if (nativeEvent.state === State.END) {\n      onOverlayRelease(nativeEvent);\n    }\n  };\n\n  const checkCropBounds = ({\n    translationX,\n    translationY,\n  }:\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\n    | { translationX: number; translationY: number }) => {\n    // Check if the pan in the x direction exceeds the bounds\n    let accDx = accumulatedPan.x + translationX;\n    // Is the new x pos less than zero?\n    if (accDx <= imageBounds.x) {\n      // Then set it to be zero and set the pan to zero too\n      accDx = imageBounds.x;\n    }\n    // Is the new x pos plus crop width going to exceed the right hand bound\n    else if (accDx + cropSize.width > imageBounds.width + imageBounds.x) {\n      // Then set the x pos so the crop frame touches the right hand edge\n      let limitedXPos = imageBounds.x + imageBounds.width - cropSize.width;\n      accDx = limitedXPos;\n    } else {\n      // It's somewhere in between - no formatting required\n    }\n    // Check if the pan in the y direction exceeds the bounds\n    let accDy = accumulatedPan.y + translationY;\n    // Is the new y pos less the top edge?\n    if (accDy <= imageBounds.y) {\n      // Then set it to be zero and set the pan to zero too\n      accDy = imageBounds.y;\n    }\n    // Is the new y pos plus crop height going to exceed the bottom bound\n    else if (accDy + cropSize.height > imageBounds.height + imageBounds.y) {\n      // Then set the y pos so the crop frame touches the bottom edge\n      let limitedYPos = imageBounds.y + imageBounds.height - cropSize.height;\n      accDy = limitedYPos;\n    } else {\n      // It's somewhere in between - no formatting required\n    }\n    // Record the accumulated pan and reset the pan refs to zero\n    panX.current.setValue(0);\n    panY.current.setValue(0);\n    setAccumluatedPan({ x: accDx, y: accDy });\n  };\n\n  const checkResizeBounds = ({\n    translationX,\n    translationY,\n  }:\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\n    | { translationX: number; translationY: number }) => {\n    // Check we haven't gone out of bounds when resizing - allow it to be\n    // resized up to the appropriate bounds if so\n    const { width: maxWidth, height: maxHeight } = imageBounds;\n    const { width: minWidth, height: minHeight } = minimumCropDimensions;\n    const { x, y } = getTargetCropFrameBounds({ translationX, translationY });\n    const animatedWidth = cropSize.width + x;\n    const animatedHeight = cropSize.height + y;\n    let finalHeight = animatedHeight;\n    let finalWidth = animatedWidth;\n    // Ensure the width / height does not exceed the boundaries -\n    // resize to the max it can be if so\n    if (animatedHeight > maxHeight) {\n      finalHeight = maxHeight;\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\n    } else if (animatedHeight < minHeight) {\n      finalHeight = minHeight;\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\n    }\n    if (animatedWidth > maxWidth) {\n      finalWidth = maxWidth;\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\n    } else if (animatedWidth < minWidth) {\n      finalWidth = minWidth;\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\n    }\n    // Update the accumulated pan with the delta from the pan refs\n    setAccumluatedPan({\n      x: accumulatedPan.x + (isLeft ? -x : 0),\n      y: accumulatedPan.y + (isTop ? -y : 0),\n    });\n    // Zero out the pan refs\n    panX.current.setValue(0);\n    panY.current.setValue(0);\n    // Update the crop size to the size after resizing\n    setCropSize({\n      height: finalHeight,\n      width: finalWidth,\n    });\n  };\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <PanGestureHandler\n        onGestureEvent={onOverlayMove}\n        onHandlerStateChange={(e) => onHandlerStateChange(e)}\n      >\n        <Animated.View\n          style={[\n            styles.overlay,\n            animatedCropSize,\n            {\n              transform: [\n                { translateX: Animated.add(panX.current, accumulatedPan.x) },\n                { translateY: Animated.add(panY.current, accumulatedPan.y) },\n              ],\n            },\n          ]}\n        >\n          {\n            // For reendering out each section of the crop overlay frame\n            horizontalSections.map((hsection) => {\n              return (\n                <View style={styles.sectionRow} key={hsection}>\n                  {verticalSections.map((vsection) => {\n                    const key = hsection + vsection;\n                    return (\n                      <View style={[styles.defaultSection]} key={key}>\n                        {\n                          // Add the corner markers to the topleft,\n                          // topright, bottomleft and bottomright corners to indicate resizing\n                          key == \"topleft\" ||\n                          key == \"topright\" ||\n                          key == \"bottomleft\" ||\n                          key == \"bottomright\" ? (\n                            <View\n                              style={[\n                                styles.cornerMarker,\n                                hsection == \"top\"\n                                  ? { top: -4, borderTopWidth: 7 }\n                                  : { bottom: -4, borderBottomWidth: 7 },\n                                vsection == \"left\"\n                                  ? { left: -4, borderLeftWidth: 7 }\n                                  : { right: -4, borderRightWidth: 7 },\n                              ]}\n                            />\n                          ) : null\n                        }\n                      </View>\n                    );\n                  })}\n                </View>\n              );\n            })\n          }\n        </Animated.View>\n      </PanGestureHandler>\n    </GestureHandlerRootView>\n  );\n};\n\nexport { ImageCropOverlay };\n\nconst styles = StyleSheet.create({\n  container: {\n    height: \"100%\",\n    width: \"100%\",\n    position: \"absolute\",\n  },\n  overlay: {\n    height: 40,\n    width: 40,\n    backgroundColor: \"#33333355\",\n    borderColor: \"#ffffff88\",\n    borderWidth: 1,\n  },\n  sectionRow: {\n    flexDirection: \"row\",\n    flex: 1,\n  },\n  defaultSection: {\n    flex: 1,\n    borderWidth: 0.5,\n    borderColor: \"#ffffff88\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  cornerMarker: {\n    position: \"absolute\",\n    borderColor: \"#ffffff\",\n    height: 30,\n    width: 30,\n  },\n});\n"]}